/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <gtksourceview/gtksourcebuffer.h>
#include <gtksourceview/gtksourceiter.h>
#include <gtksourceview/gtksourcelanguage.h>
#include <gtksourceview/gtksourcelanguagesmanager.h>
#include <gtksourceview/gtksourcemarker.h>
#include <gtksourceview/gtksourceprintjob.h>
#include <gtksourceview/gtksourcestylescheme.h>
#include <gtksourceview/gtksourcetag.h>
#include <gtksourceview/gtksourcetagstyle.h>
#include <gtksourceview/gtksourcetagtable.h>
#include <gtksourceview/gtksourceview.h>
#include <gtksourceview/gtksourceview-typebuiltins.h>

#include "config.h"

static PyObject *
_gslist_to_pylist_objs (const GSList *source)
{
    const GSList *iter;
    PyObject *dest = PyList_New (0);
    for (iter = source; iter != NULL; iter = iter->next)
    {
        PyObject *item = pygobject_new ((GObject *)iter->data);
        PyList_Append (dest, item);
        Py_DECREF (item);
    }
    return dest;
}

static PyObject *
_gslist_to_pylist_strs (const GSList *source)
{
    const GSList *iter;
    PyObject *dest = PyList_New (0);
    for (iter = source; iter != NULL; iter = iter->next)
    {
        PyObject *item = PyString_FromString ((char *)iter->data);
        PyList_Append (dest, item);
        Py_DECREF (item);
    }
    return dest;
}
%%
modulename gtksourceview
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.TextView as PyGtkTextView_Type
import gtk.TextBuffer as PyGtkTextBuffer_Type
import gtk.TextIter as PyGtkTextIter_Type
import gtk.TextTag as PyGtkTextTag_Type
import gtk.TextMark as PyGtkTextMark_Type
import gtk.TextTagTable as PyGtkTextTagTable_Type
import mateprint.Config as PyMatePrintConfig_Type
import pango.FontDescription as PyPangoFontDescription_Type
%%
ignore
    gtk_source_view_new_with_buffer
    gtk_source_buffer_new_with_language
    gtk_source_print_job_new_with_buffer
%%
ignore-glob	
    *_get_type
    _*
%%
override gtk_source_view_new

static int
_wrap_gtk_source_view_new (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    PyGObject *buffer = NULL;
    if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|O!:GtkSourceView.__init__", kwlist,
            &PyGtkSourceBuffer_Type, &buffer))
        return -1;
    
    if (buffer)
        pygobject_construct(self, "buffer", buffer->obj, NULL);
    else
        pygobject_construct(self, NULL);
    
    if (!self->obj) {
        PyErr_SetString (PyExc_RuntimeError, "could not create GtkSourceView object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_SOURCE_VIEW
%%
override gtk_source_buffer_new

static int
_wrap_gtk_source_buffer_new (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "table", "lang", NULL };
    PyGObject *table = NULL, *lang = NULL;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|O!O!:GtkSourceBuffer.__init__", kwlist,
            &PyGtkSourceTagTable_Type, &table, &PyGtkSourceLanguage_Type, &lang))
        return -1;

    if (lang && !table)
        pygobject_construct(self, "language", lang->obj, NULL);
    else if (!lang && table)
        pygobject_construct(self, "tag_table", table->obj, NULL);
    else if (lang && table)
        pygobject_construct(self, "language", lang->obj, "tag_table", table->obj, NULL);
    else
        pygobject_construct(self, NULL);
    if (!self->obj) {
        PyErr_SetString (PyExc_RuntimeError, "could not create GtkSourceBuffer object");
        return -1;
    }
    return 0;
}
%%
new-constructor GTK_TYPE_SOURCE_BUFFER
%%
override gtk_source_print_job_new

static int
_wrap_gtk_source_print_job_new (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "config", "buffer", NULL };
    PyGObject *config = NULL, *buffer = NULL;
    if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|O!O!:GtkSourcePrintJob.__init__", kwlist,
            &PyMatePrintConfig_Type, &config, &PyGtkSourceBuffer_Type, &buffer))
        return -1;
    
    if (config && buffer)
        self->obj = (GObject *)gtk_source_print_job_new_with_buffer (
            MATE_PRINT_CONFIG(config->obj), GTK_SOURCE_BUFFER(buffer->obj));
    else if (buffer)
        self->obj = (GObject *)gtk_source_print_job_new_with_buffer (NULL,
            GTK_SOURCE_BUFFER(buffer->obj));
    else if (config)
        self->obj = (GObject *)gtk_source_print_job_new (MATE_PRINT_CONFIG(config->obj));
    else
        self->obj = (GObject *)gtk_source_print_job_new (NULL);
    
    if (!self->obj) {
        PyErr_SetString (PyExc_RuntimeError, "could not create GtkSourcePrintJob object");
        return -1;
    }
    pygobject_register_wrapper ((PyObject *)self);
    return 0;
}
%%
override gtk_source_buffer_get_markers_in_region

static PyObject *
_wrap_gtk_source_buffer_get_markers_in_region (PyGObject *self, PyObject *args)
{
    GSList *source;
    PyObject *dest, *py_start, *py_end;
    GtkTextIter *start, *end;
    if (!PyArg_ParseTuple (args, "OO:GtkSourceLanguage.get_tags", &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check (py_start, GTK_TYPE_TEXT_ITER) && 
        pyg_boxed_check (py_end, GTK_TYPE_TEXT_ITER))
    {
        start = pyg_boxed_get (py_start, GtkTextIter);
        end = pyg_boxed_get (py_end, GtkTextIter);
    } else {
        PyErr_SetString (PyExc_TypeError, "start and end must be gtk.TextIters");
        return NULL;
    }
    
    source = gtk_source_buffer_get_markers_in_region (GTK_SOURCE_BUFFER(self->obj), start, end);
    dest = _gslist_to_pylist_objs(source);
    g_slist_free(source);
    return dest;
}
%%
override gtk_source_language_get_tags

static PyObject *
_wrap_gtk_source_language_get_tags (PyGObject *self)
{
    GSList *source;
    PyObject *dest;
    source = gtk_source_language_get_tags (GTK_SOURCE_LANGUAGE(self->obj));
    dest = _gslist_to_pylist_objs(source);
    g_slist_free(source);
    return dest;
}
%%
override gtk_source_language_get_mime_types

static PyObject *
_wrap_gtk_source_language_get_mime_types (PyGObject *self)
{
    GSList *source;
    PyObject *dest;
    source = gtk_source_language_get_mime_types (GTK_SOURCE_LANGUAGE(self->obj));
    dest = _gslist_to_pylist_strs(source);
    g_slist_free(source);
    return dest;
}
%%
override gtk_source_language_set_mime_types

static PyObject *
_wrap_gtk_source_language_set_mime_types (PyGObject *self, PyObject *args)
{
    PyObject *source;
    GSList *dest = NULL;
    int len, i;
    if (!PyArg_ParseTuple (args, "O:GtkSourceTagTable.add_tags", &source))
        return NULL;
    if (!PySequence_Check (source))
    {
        PyErr_SetString (PyExc_TypeError, "argument must be a sequence");
        return NULL;
    }
    
    len = PySequence_Length (source);
    for (i = 0; i < len; i++)
    {
        PyObject *item = PySequence_GetItem (source, i);
        Py_DECREF (item);
        if (!PyString_Check (item) && !PyUnicode_Check (item))
        {
            PyErr_SetString (PyExc_TypeError, "sequence item not a string or unicode object");
            g_slist_free (dest);
            return NULL;
        }
        dest = g_slist_append(dest, PyString_AsString(item));
    }
    gtk_source_tag_table_add_tags(GTK_SOURCE_TAG_TABLE(self->obj), dest);
    g_slist_free(dest);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_source_languages_manager_get_available_languages

static PyObject *
_wrap_gtk_source_languages_manager_get_available_languages (PyGObject *self)
{
    const GSList *source;
    PyObject *dest;
    source = gtk_source_languages_manager_get_available_languages (
        GTK_SOURCE_LANGUAGES_MANAGER(self->obj));
    dest = _gslist_to_pylist_objs(source);
    return dest;
}
%%
override gtk_source_languages_manager_get_lang_files_dirs

static PyObject *
_wrap_gtk_source_languages_manager_get_lang_files_dirs (PyGObject *self)
{
    const GSList *source;
    PyObject *dest;
    source = gtk_source_languages_manager_get_lang_files_dirs (
        GTK_SOURCE_LANGUAGES_MANAGER(self->obj));
    dest = _gslist_to_pylist_strs(source);
    return dest;
}
%%
override gtk_source_style_scheme_get_style_names

static PyObject *
_wrap_gtk_source_style_scheme_get_style_names (PyGObject *self)
{
    GSList *source;
    PyObject *dest;
    source = gtk_source_style_scheme_get_style_names (GTK_SOURCE_STYLE_SCHEME(self->obj));
    dest = _gslist_to_pylist_strs(source);
    g_slist_free(source);
    return dest;
}
%%
override-attr GtkSourceTagStyle.bold

static int
_wrap_gtk_source_tag_style__set_bold(PyGObject *self, PyObject *value, void *closure)
{
    pyg_boxed_get (self, GtkSourceTagStyle)->bold = PyObject_IsTrue(value);
    return 0;
}
%%
override-attr GtkSourceTagStyle.italic

static int
_wrap_gtk_source_tag_style__set_italic(PyGObject *self, PyObject *value, void *closure)
{
    pyg_boxed_get (self, GtkSourceTagStyle)->italic = PyObject_IsTrue(value);
    return 0;
}
%%
override-attr GtkSourceTagStyle.underline

static int
_wrap_gtk_source_tag_style__set_underline(PyGObject *self, PyObject *value, void *closure)
{
    pyg_boxed_get (self, GtkSourceTagStyle)->underline = PyObject_IsTrue(value);
    return 0;
}
%%
override-attr GtkSourceTagStyle.strikethrough

static int
_wrap_gtk_source_tag_style__set_strikethrough(PyGObject *self, PyObject *value, void *closure)
{
    pyg_boxed_get (self, GtkSourceTagStyle)->strikethrough = PyObject_IsTrue(value);
    return 0;
}
%%
override-attr GtkSourceTagStyle.foreground

static int
_wrap_gtk_source_tag_style__set_foreground(PyGObject *self, PyObject *value, void *closure)
{
    if (value == Py_None)
        pyg_boxed_get (self, GtkSourceTagStyle)->mask &= ~GTK_SOURCE_TAG_STYLE_USE_FOREGROUND;
    else {
        if (!pyg_boxed_check (value, GDK_TYPE_COLOR)) {
            PyErr_SetString(PyExc_TypeError, "a gtk.gdk.Color object or None is required");
            return -1;
        }
        pyg_boxed_get (self, GtkSourceTagStyle)->foreground = *(pyg_boxed_get (value, GdkColor));
        pyg_boxed_get (self, GtkSourceTagStyle)->mask |= GTK_SOURCE_TAG_STYLE_USE_FOREGROUND;
    }
    return 0;
}
%%
override-attr GtkSourceTagStyle.background

static int
_wrap_gtk_source_tag_style__set_background(PyGObject *self, PyObject *value, void *closure)
{
    if (value == Py_None)
        pyg_boxed_get (self, GtkSourceTagStyle)->mask &= ~GTK_SOURCE_TAG_STYLE_USE_BACKGROUND;
    else {
        if (!pyg_boxed_check (value, GDK_TYPE_COLOR)) {
            PyErr_SetString(PyExc_TypeError, "a gtk.gdk.Color object or None is required");
            return -1;
        }
        pyg_boxed_get (self, GtkSourceTagStyle)->background = *(pyg_boxed_get (value, GdkColor));
        pyg_boxed_get (self, GtkSourceTagStyle)->mask |= GTK_SOURCE_TAG_STYLE_USE_BACKGROUND;
    }    
    return 0;
}
%%
override gtk_source_tag_table_add_tags

static PyObject *
_wrap_gtk_source_tag_table_add_tags (PyGObject *self, PyObject *args)
{
    PyObject *source;
    GSList *dest = NULL;
    int len, i;
    if (!PyArg_ParseTuple (args, "O:GtkSourceTagTable.add_tags", &source))
        return NULL;
    if (!PySequence_Check (source))
    {
        PyErr_SetString (PyExc_TypeError, "argument must be a sequence");
        return NULL;
    }
    
    len = PySequence_Length (source);
    for (i = 0; i < len; i++)
    {
        PyObject *item = PySequence_GetItem (source, i);
        Py_DECREF (item);
        if (!PyObject_TypeCheck (item, &PyGtkTextTag_Type))
        {
            PyErr_SetString (PyExc_TypeError, "sequence item not a gtk.TextTag");
            g_slist_free (dest);
            return NULL;
        }
        dest = g_slist_append(dest, GTK_TEXT_TAG(((PyGObject *)item)->obj));
    }
    gtk_source_tag_table_add_tags(GTK_SOURCE_TAG_TABLE(self->obj), dest);
    g_slist_free(dest);
    Py_INCREF (Py_None);
    return Py_None;
}
%%
override gtk_source_print_job_get_text_margins

static PyObject *
_wrap_gtk_source_print_job_get_text_margins (PyGObject *self)
{
    gdouble top, bottom, left, right;
    gtk_source_print_job_get_text_margins (GTK_SOURCE_PRINT_JOB(self->obj),
        &top, &bottom, &left, &right);
    return Py_BuildValue("(dddd)", top, bottom, left, right);
}
%%
override gtk_source_iter_forward_search_deprecated kwargs
static PyObject *
_wrap_gtk_source_iter_forward_search_deprecated(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "str", "flags", "match_start", "match_end", "limit", NULL };
    PyObject *py_iter, *py_flags = NULL, *py_match_start, *py_match_end, *py_limit;
    char *str;
    GtkSourceSearchFlags flags;
    GtkTextIter *iter = NULL, *match_start = NULL, *match_end = NULL, *limit = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OsOOOO:gtk_source_iter_forward_search", kwlist, &py_iter, &str, &py_flags, &py_match_start, &py_match_end, &py_limit))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "renamed to gtksourceview.source_iter_forward_search") < 0)
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    if (pyg_flags_get_value(GTK_TYPE_SOURCE_SEARCH_FLAGS, py_flags, (gint *)&flags))
        return NULL;
    if (pyg_boxed_check(py_match_start, GTK_TYPE_TEXT_ITER))
        match_start = pyg_boxed_get(py_match_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "match_start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_match_end, GTK_TYPE_TEXT_ITER))
        match_end = pyg_boxed_get(py_match_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "match_end should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
        limit = pyg_boxed_get(py_limit, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "limit should be a GtkTextIter");
        return NULL;
    }
    ret = gtk_source_iter_forward_search(iter, str, flags, match_start, match_end, limit);
    return PyBool_FromLong(ret);

}
%%
override gtk_source_iter_backward_search_deprecated kwargs
static PyObject *
_wrap_gtk_source_iter_backward_search_deprecated(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "str", "flags", "match_start", "match_end", "limit", NULL };
    PyObject *py_iter, *py_flags = NULL, *py_match_start, *py_match_end, *py_limit;
    char *str;
    GtkSourceSearchFlags flags;
    GtkTextIter *iter = NULL, *match_start = NULL, *match_end = NULL, *limit = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OsOOOO:gtk_source_iter_backward_search", kwlist, &py_iter, &str, &py_flags, &py_match_start, &py_match_end, &py_limit))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "renamed to gtksourceview.source_iter_backward_search") < 0)
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    if (pyg_flags_get_value(GTK_TYPE_SOURCE_SEARCH_FLAGS, py_flags, (gint *)&flags))
        return NULL;
    if (pyg_boxed_check(py_match_start, GTK_TYPE_TEXT_ITER))
        match_start = pyg_boxed_get(py_match_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "match_start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_match_end, GTK_TYPE_TEXT_ITER))
        match_end = pyg_boxed_get(py_match_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "match_end should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
        limit = pyg_boxed_get(py_limit, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "limit should be a GtkTextIter");
        return NULL;
    }
    ret = gtk_source_iter_backward_search(iter, str, flags, match_start, match_end, limit);
    return PyBool_FromLong(ret);

}
%%
override gtk_source_iter_find_matching_bracket_deprecated kwargs
static PyObject *
_wrap_gtk_source_iter_find_matching_bracket_deprecated(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    int ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:gtk_source_iter_find_matching_bracket", kwlist, &py_iter))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "renamed to gtksourceview.source_iter_find_matching_bracket") < 0)
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    ret = gtk_source_iter_find_matching_bracket(iter);
    return PyBool_FromLong(ret);

}
%%
override gtk_source_style_scheme_get_default_deprecated noargs
static PyObject *
_wrap_gtk_source_style_scheme_get_default_deprecated(PyObject *self)
{
    GtkSourceStyleScheme *ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "renamed to gtksourceview.source_style_scheme_get_default") < 0)
        return NULL;
    ret = gtk_source_style_scheme_get_default();
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

%%
override-slot GtkSourceLanguage.tp_repr

static PyObject *
_wrap_gtk_source_language_tp_repr (PyGObject *self)
{
    PyObject *repr;
    char *id = gtk_source_language_get_id(GTK_SOURCE_LANGUAGE(self->obj));
    repr = PyString_FromFormat("<gtksourceview.SourceLanguage (id=\"%s\") at 0x%lx",
                               id, (long) self);
    g_free(id);
    return repr;
}

